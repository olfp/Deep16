; =============================================
; Enhanced Deep16 Forth Kernel
; Using revised architecture features
; =============================================

.org 0x0100
.code

.equ IP R11
.equ RSP R12
.equ SP R13
.equ NEXT R10
.equ POS R7
.equ SCR R8
.equ MASK R4

; Register Usage:
; R0: Temporary (LDI target)
; R1: Temporary for operations
; R2: Temporary for operations  
; R3: Temporary for operations
; R4: AND mask (0x00FF)
; R5: Unused
; R6: Unused
; R7: Screen position counter
; R8/R9: Screen pointer pair for ES access
; R10: NEXT jump target
; R11: Instruction Pointer (IP)
; R12: Return Stack Pointer (RSP)
; R13: Stack Pointer (SP)
; R14: Link Register (LR)
; R15: Program Counter (PC)

; Forth Memory Layout:
; 0x0100-0x01FF: Forth kernel
; 0x0200-0x02FF: User dictionary
; 0x0300-0x7FFF: Data stack, return stack, heap

; =============================================
; Forth Kernel Implementation
; =============================================

forth_start:
    ; Initialize stack pointers
    LDI 0x7FF0
    MOV SP, R0        ; Data stack grows down from 0x7FF0 (R13)
    LSI RSP, 0x7FE0   ; Use LSI for small literal - return stack at 0x7FE0 (R12)
    
    ; Initialize instruction pointer to user program (R11)
    LDI user_program
    MOV IP, R0
    
    ; Set up screen segment for output using R8/R9 pair
    LSI R8, 0xF000    ; Use LSI for segment value
    MVS ES, R8        ; ES = 0xF000
    LSI R9, 0x1000    ; Use LSI for screen offset - screen at 0xF1000
    ERD R8            ; Use R8/R9 for ES access (PSW.ER=1000, DE=1)
    
    ; Clear screen position counter
    LSI POS, 0        ; Use LSI for zero
    
    ; Set up AND mask for byte operations
    LSI MASK, 0x00FF  ; Use LSI for mask value

    ; Ensure Data Segment points to physical 0x0000 for LD/ST
    LSI R0, 0
    MVS DS, R0
    
    ; Set up NEXT jump target
    LDI next
    MOV NEXT, R0

    ; Jump to inner interpreter
    JMP NEXT          ; Use JMP alias
    NOP

; =============================================
; Forth Inner Interpreter
; =============================================

next:
    ; Fetch next word from instruction stream
    LD R1, [IP]      ; Enhanced syntax: R1 = [R11] - get codeword
    ADD IP, 1         ; R11++ - advance instruction pointer
    
    ; Jump to codeword directly
    JMP R1           ; Use JMP alias
    NOP

; =============================================
; Stack Primitives
; =============================================

; EXIT - return from word
d_exit:
    LD IP, [RSP]     ; Enhanced syntax: Pop R11 from return stack
    ADD RSP, 1       ; Adjust return stack
    JMP NEXT         ; Use JMP alias
    NOP

; LIT - push literal
d_lit:
    LD R1, [IP]      ; Enhanced syntax: Get literal value
    ADD IP, 1        ; Advance R11
    SUB SP, 1        ; Pre-decrement stack pointer
    ST R1, [SP]      ; Enhanced syntax: Push to stack
    JMP NEXT         ; Use JMP alias
    NOP

; DUP - duplicate top of stack
d_dup:
    LD R1, [SP]      ; Enhanced syntax: Get top of stack
    SUB SP, 1        ; Pre-decrement
    ST R1, [SP]      ; Enhanced syntax: Push duplicate
    JMP NEXT         ; Use JMP alias
    NOP

; DROP - drop top of stack  
d_drop:
    ADD SP, 1        ; Simply increment stack pointer
    JMP NEXT         ; Use JMP alias
    NOP

; SWAP - swap top two stack items
d_swap:
    LD R1, [SP]      ; Enhanced syntax: R1 = top
    LD R2, [SP+1]    ; Enhanced syntax: R2 = second
    ST R1, [SP+1]    ; Enhanced syntax: Swap positions
    ST R2, [SP]
    JMP NEXT         ; Use JMP alias
    NOP

; =============================================
; Memory Operations
; =============================================

; @ (fetch) - ( addr -- value )
d_fetch:
    LD R1, [SP]      ; Enhanced syntax: Get address from stack
    LD R1, [R1]      ; Enhanced syntax: Fetch value from memory
    ST R1, [SP]      ; Enhanced syntax: Replace TOS with value
    JMP NEXT         ; Use JMP alias
    NOP

; ! (store) - ( value addr -- )
d_store:
    LD R1, [SP]      ; Enhanced syntax: Address (TOS)
    LD R2, [SP+1]    ; Enhanced syntax: Value (second)
    ST R2, [R1]      ; Enhanced syntax: Store value at address
    ADD SP, 2        ; Drop both items
    JMP NEXT         ; Use JMP alias
    NOP

; =============================================
; I/O Operations
; =============================================

; EMIT - output character
d_emit:
    LD R1, [SP]      ; Enhanced syntax: Get character from stack
    ADD SP, 1        ; Drop it
    
    STS R1, ES, [SCR] ; Enhanced syntax: ES screen write
    ADD SCR, 1        ; Advance screen pointer
    ADD POS, 1        ; Advance position counter
    
    ; Simple bounds checking - reset if at end of screen
    LSI R2, 2000     ; Use LSI for screen size
    SUB R2, POS      ; 2000 - current_position
    JNZ emit_done    ; If not zero, continue
    NOP
    LSI SCR, 0x1000  ; Use LSI to reset screen pointer
    LSI POS, 0       ; Use LSI to reset position counter
    
emit_done:
    JMP NEXT         ; Use JMP alias
    NOP

; TELL - print packed string until zero byte
d_tell:
    LD R3, [SP]      ; Enhanced syntax: Get string address
    ADD SP, 1

tell_loop:
    LD R1, [R3]      ; Enhanced syntax: Get packed word
    ADD R1, 0
    JZ tell_done
    NOP

    ; Process high byte first (big-endian packed)
    MOV R2, R1
    SWB R2           ; Swap bytes for processing
    AND R2, MASK     ; Get high byte (was low byte before SWB)
    ADD R2, 0
    JZ skip_high
    NOP
    STS R2, ES, [SCR] ; Enhanced syntax
    ADD SCR, 1
    ADD POS, 1
    LSI R2, 2000     ; Use LSI for bounds check
    SUB R2, POS
    JNZ high_ok
    NOP
    LSI SCR, 0x1000  ; Use LSI to reset
    LSI POS, 0       ; Use LSI to reset
high_ok:

skip_high:
    MOV R2, R1
    AND R2, MASK     ; Get low byte
    ADD R2, 0
    JZ tell_next_word
    NOP
    STS R2, ES, [SCR] ; Enhanced syntax
    ADD SCR, 1
    ADD POS, 1
    
    LSI R2, 2000     ; Use LSI for bounds check
    SUB R2, POS
    JNZ tell_next_word
    NOP
    LSI SCR, 0x1000  ; Use LSI to reset
    LSI POS, 0       ; Use LSI to reset

tell_next_word:
    ADD R3, 1
    JNO tell_loop
    NOP

tell_done:
    JMP NEXT
    NOP

; CR - carriage return (move to next line)
d_cr:
    ; Calculate current column: position % 80
    MOV R1, POS      ; Copy position
    LSI R2, 80       ; Use LSI for line width
cr_mod_loop:
    SUB R1, R2       ; Subtract 80
    JN cr_done_mod   ; If negative, done
    NOP
    JNO cr_mod_loop
    NOP
cr_done_mod:
    ADD R1, R2       ; Add back the last 80
    ; Now R1 = current column
    
    ; Calculate spaces to next line: 80 - current_column
    LSI R0, 80       ; Use LSI
    SUB R0, R1       ; 80 - current_column
    MOV R2, R0       ; R2 = spaces needed
    
    ADD R2, 0
    JZ cr_done
    NOP
    ADD SCR, R2
    ADD POS, R2
    
cr_done:
    JMP NEXT         ; Use JMP alias
    NOP

; =============================================
; Arithmetic Operations
; =============================================

d_add:
    LD R2, [SP]      ; Enhanced syntax: a
    LD R1, [SP+1]    ; Enhanced syntax: b
    ADD R1, R2       ; b+a
    ADD SP, 1        ; drop a
    ST R1, [SP]      ; Enhanced syntax: push result
    JMP NEXT         ; Use JMP alias
    NOP

d_sub:
    LD R2, [SP]      ; Enhanced syntax: a
    LD R1, [SP+1]    ; Enhanced syntax: b  
    SUB R1, R2       ; b-a
    ADD SP, 1        ; drop a
    ST R1, [SP]      ; Enhanced syntax: push result
    JMP NEXT         ; Use JMP alias
    NOP

d_mul:
    LD R2, [SP]      ; Enhanced syntax: a
    LD R1, [SP+1]    ; Enhanced syntax: b
    MUL R1, R2       ; b*a
    ADD SP, 1        ; drop a
    ST R1, [SP]      ; Enhanced syntax: push result
    JMP NEXT         ; Use JMP alias
    NOP

; =============================================
; Print Operations
; =============================================

; . (DOT) - print top of stack as decimal
d_dot:
    LD R1, [SP]      ; Enhanced syntax: value
    ADD SP, 1        ; pop
    ADD R1, 0
    JZ dot_zero
    NOP

    LSI R5, 0        ; Use LSI: count = 0
    LSI R6, 10       ; Use LSI: divisor

dot_digit_loop:
    DIV R1, R6
    MOV R3, R2       ; remainder
    LSI R0, 48       ; Use LSI: ASCII '0'
    ADD R3, R0       ; Convert to ASCII
    SUB SP, 1
    ST R3, [SP]      ; Enhanced syntax: push digit
    ADD R5, 1
    ADD R1, 0
    JZ dot_print
    NOP
    JNO dot_digit_loop
    NOP

dot_zero:
    LSI R0, 48       ; Use LSI: '0'
    SUB SP, 1
    ST R0, [SP]      ; Enhanced syntax
    LSI R5, 1        ; Use LSI: count = 1

dot_print:
    ADD R5, 0
    JZ dot_done
    NOP
    LD R1, [SP]      ; Enhanced syntax
    ADD SP, 1
    STS R1, ES, [SCR] ; Enhanced syntax
    ADD SCR, 1
    ADD POS, 1
    SUB R5, 1
    JNO dot_print
    NOP

dot_done:
    JMP NEXT
    NOP

; .H (DOT_HEX) - print top of stack as hexadecimal (NEW)
d_dot_hex:
    LD R1, [SP]      ; Enhanced syntax: value
    ADD SP, 1        ; pop
    LSI R3, 4        ; Use LSI: shift count = 4
    LSI R5, 4        ; Use LSI: digit count (16 bits = 4 hex digits)
    
hex_loop:
    MOV R2, R1
    AND R2, 0x000F   ; Get lowest nibble
    LSI R0, 48       ; Use LSI: '0'
    ADD R2, R0       ; Convert to ASCII
    CMP R2, 57       ; '9'
    JNO hex_digit    ; If <= '9', it's fine
    NOP
    ADD R2, 7        ; Adjust to 'A'-'F'
hex_digit:
    STS R2, ES, [SCR] ; Enhanced syntax
    ADD SCR, 1
    ADD POS, 1
    SRA R1, 4        ; Use shift: move to next nibble
    SUB R5, 1
    JNZ hex_loop
    NOP
    
    JMP NEXT
    NOP

; Halt word
d_halt:
    HLT

; =============================================
; Enhanced String Interpreter (EVAL)
; Uses PSW flags for state tracking
; =============================================

d_eval:
    LD R3, [SP]      ; Enhanced syntax: R3 = address of packed string
    ADD SP, 1
    CLR 8            ; Use PSW flag: byteSel = 0 (0=high,1=low)

eval_next:
    LD R1, [R3]      ; Enhanced syntax: current word
    ADD R1, 0
    JZ eval_done
    NOP

    MOV R2, R1
    TBS R0, 8        ; Use TBS: test PSW bit 8 (byteSel)
    JNZ eval_use_low
    NOP
    ; Use high byte
    SWB R2           ; Swap to get high byte in low position
    AND R2, MASK
    JMP eval_have_char
    NOP
eval_use_low:
    ; Use low byte
    AND R2, MASK
eval_have_char:
    ; Skip spaces
    MOV R5, R2
    LSI R0, 32       ; Use LSI: space character
    SUB R5, R0
    JNZ eval_after_space
    NOP
    ; Consume space and continue
    TBS R0, 8        ; Test byteSel
    JNZ eval_consume_low
    NOP
    SET 8            ; Switch to low byte of same word
    JMP eval_next
    NOP
eval_consume_low:
    CLR 8            ; Switch to high byte of next word
    ADD R3, 1
    JMP eval_next
    NOP

eval_after_space:
    ; Check for operators
    MOV R5, R2
    LSI R0, 43       ; Use LSI: '+'
    SUB R5, R0
    JNZ eval_after_add
    NOP
    ; Handle addition
    LD R2, [SP]      ; Enhanced syntax
    LD R1, [SP+1]    ; Enhanced syntax
    ADD R1, R2
    ADD SP, 1
    ST R1, [SP]      ; Enhanced syntax
    JMP eval_consume_op
    NOP

eval_after_add:
    MOV R5, R2
    LSI R0, 42       ; Use LSI: '*'
    SUB R5, R0
    JNZ eval_after_mul
    NOP
    ; Handle multiplication
    LD R2, [SP]      ; Enhanced syntax
    LD R1, [SP+1]    ; Enhanced syntax
    MUL R1, R2
    ADD SP, 1
    ST R1, [SP]      ; Enhanced syntax
    JMP eval_consume_op
    NOP

eval_after_mul:
    MOV R5, R2
    LSI R0, 46       ; Use LSI: '.'
    SUB R5, R0
    JNZ eval_after_dot
    NOP
    ; Handle dot (print)
    LD R1, [SP]      ; Enhanced syntax
    ADD SP, 1
    JMP d_dot        ; Reuse existing dot routine
    NOP

eval_after_dot:
    ; Parse numbers (0-9)
    MOV R5, R2
    LSI R0, 48       ; Use LSI: '0'
    SUB R5, R0
    JN eval_next     ; Below '0'
    NOP
    MOV R5, R2
    LSI R0, 57       ; Use LSI: '9'
    SUB R0, R5
    JN eval_next     ; Above '9'
    NOP

    ; Parse number sequence
    LSI R1, 0        ; Use LSI: acc = 0
eval_num_loop:
    ; Add current digit
    MOV R5, R2
    LSI R0, 48       ; Use LSI: '0'
    SUB R5, R0       ; Convert to digit value
    MOV R6, R1
    LSI R7, 10       ; Use LSI: base 10
    MUL R6, R7       ; acc * 10
    ADD R6, R5       ; + digit
    MOV R1, R6
    
    ; Peek next character
    TBS R0, 8        ; Test byteSel
    JNZ eval_peek_next_low
    NOP
    ; Currently at high byte, next is low byte of same word
    LD R7, [R3]      ; Enhanced syntax
    AND R7, MASK     ; Low byte
    MOV R2, R7
    SET 8            ; Move to low byte position
    JMP eval_check_next_digit
    NOP
eval_peek_next_low:
    ; Currently at low byte, next is high byte of next word
    ADD R3, 1
    LD R7, [R3]      ; Enhanced syntax
    SWB R7           ; Swap to get high byte
    AND R7, MASK
    MOV R2, R7
    CLR 8            ; Move to high byte position
eval_check_next_digit:
    ; Check if next character is a digit
    MOV R5, R2
    LSI R0, 48       ; Use LSI: '0'
    SUB R5, R0
    JN eval_num_done ; Not a digit
    NOP
    MOV R5, R2
    LSI R0, 57       ; Use LSI: '9'
    SUB R0, R5
    JN eval_num_done ; Not a digit
    NOP
    JMP eval_num_loop ; Continue parsing
    NOP

eval_num_done:
    ; Push parsed number
    SUB SP, 1
    ST R1, [SP]      ; Enhanced syntax
    JMP eval_next
    NOP

eval_consume_op:
    ; Consume the operator character
    TBS R0, 8        ; Test byteSel
    JNZ eval_op_was_low
    NOP
    SET 8            ; Was high byte, move to low
    JMP eval_next
    NOP
eval_op_was_low:
    CLR 8            ; Was low byte, move to next word's high
    ADD R3, 1
    JMP eval_next
    NOP

eval_done:
    CLR 8            ; Clear state flag
    JMP NEXT
    NOP

; =============================================
; Enhanced Demo Program
; =============================================
user_program:
    .word d_lit
    .word program_msg
    .word d_tell        ; Print "Deep16 Forth Enhanced"
    .word d_lit
    .word 42
    .word d_dup
    .word d_dot         ; Print "42"
    .word d_lit
    .word hex_msg
    .word d_tell        ; Print " hex: "
    .word d_lit
    .word 0xABCD
    .word d_dot_hex     ; Print "ABCD" (NEW hexadecimal output)
    .word d_cr
    .word d_lit
    .word calc_msg
    .word d_tell        ; Print "Test: "
    .word d_lit
    .word 10
    .word d_lit
    .word 7
    .word d_add         ; 10 + 7 = 17
    .word d_lit
    .word 3
    .word d_mul         ; 17 * 3 = 51
    .word d_dot         ; Print "51"
    .word d_cr
    .word d_halt

; Optimized string packing for sequential access
program_msg:
    .word 0x6544       ; 'e' 'D' (swapped for sequential access)
    .word 0x7036       ; 'p' '6'
    .word 0x3120       ; '1' ' '
    .word 0x6F46       ; 'o' 'F'
    .word 0x7472       ; 't' 'r'
    .word 0x2068       ; ' ' 'h'
    .word 0x6E45       ; 'n' 'E'
    .word 0x6168       ; 'a' 'h'
    .word 0x636E       ; 'c' 'n'
    .word 0x6465       ; 'd' 'e'
    .word 0x0000       ; Null terminator

hex_msg:
    .word 0x6820       ; 'h' ' '
    .word 0x7865       ; 'x' 'e'
    .word 0x203A       ; ' ' ':'
    .word 0x0000       ; Null terminator

calc_msg:
    .word 0x6554       ; 'e' 'T'
    .word 0x7473       ; 't' 's'
    .word 0x203A       ; ' ' ':'
    .word 0x0000       ; Null terminator

; =============================================
; Enhanced Dictionary Headers
; =============================================

dict_start:

; EXIT
.word 0                ; Link field (end of chain)
.word 0x4004           ; Length=4, "EXIT"
.word 0x5845           ; 'X' 'E' (swapped for sequential access)
.word 0x5449           ; 'T' 'I'
.word 0x0000           ; Padding
.word d_exit

; LIT  
.word dict_start       ; Link to previous
.word 0x4003           ; Length=3, "LIT"
.word 0x494C           ; 'I' 'L' (swapped)
.word 0x0054           ; 'T' + padding
.word d_lit

; DUP
.word dict_start+12    ; Link to previous
.word 0x4003           ; Length=3, "DUP"
.word 0x5544           ; 'U' 'D' (swapped)
.word 0x0050           ; 'P' + padding
.word d_dup

; .H (DOT_HEX) - NEW hexadecimal print
.word dict_start+24    ; Link to previous
.word 0x4002           ; Length=2, ".H"
.word 0x482E           ; 'H' '.' (swapped)
.word d_dot_hex        ; Code field

; =============================================
; End of Enhanced Kernel
; =============================================

kernel_end:
    HLT
